/**
 * Tests for SVG export utility
 *
 * @see Story 4.6: Export Graph as PNG/SVG Images - AC3, AC4, AC5
 */
import { beforeEach, describe, expect, it } from 'vitest'

import { exportSvg } from '../utils/exportSvg'

/**
 * Read blob content as text (compatible with jsdom which may lack Blob.text())
 */
function readBlobAsText(blob: Blob): Promise<string> {
  return new Promise((resolve, reject) => {
    const reader = new FileReader()
    reader.onload = () => resolve(reader.result as string)
    reader.onerror = reject
    reader.readAsText(blob)
  })
}

describe('exportSvg', () => {
  let mockSvg: SVGSVGElement

  beforeEach(() => {
    mockSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg')
    mockSvg.setAttribute('width', '800')
    mockSvg.setAttribute('height', '600')

    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle')
    circle.setAttribute('cx', '100')
    circle.setAttribute('cy', '100')
    circle.setAttribute('r', '50')
    mockSvg.appendChild(circle)
  })

  it('should export SVG as blob with correct type', async () => {
    const result = await exportSvg({
      svgElement: mockSvg,
      options: {
        format: 'svg',
        scope: 'viewport',
        resolution: 1,
        includeLegend: false,
        includeWatermark: false,
        backgroundColor: '#ffffff',
      },
      projectName: 'test-project',
    })

    expect(result.blob).toBeInstanceOf(Blob)
    expect(result.blob.type).toBe('image/svg+xml')
  })

  it('should generate correct filename with project name and date', async () => {
    const result = await exportSvg({
      svgElement: mockSvg,
      options: {
        format: 'svg',
        scope: 'viewport',
        resolution: 1,
        includeLegend: false,
        includeWatermark: false,
        backgroundColor: '#ffffff',
      },
      projectName: 'mono-guard',
    })

    expect(result.filename).toMatch(/^mono-guard-dependency-graph-\d{4}-\d{2}-\d{2}\.svg$/)
  })

  it('should return width and height from SVG attributes', async () => {
    const result = await exportSvg({
      svgElement: mockSvg,
      options: {
        format: 'svg',
        scope: 'viewport',
        resolution: 1,
        includeLegend: false,
        includeWatermark: false,
        backgroundColor: '#ffffff',
      },
      projectName: 'test',
    })

    expect(result.width).toBe(800)
    expect(result.height).toBe(600)
  })

  it('should include background rect when backgroundColor is not transparent', async () => {
    const result = await exportSvg({
      svgElement: mockSvg,
      options: {
        format: 'svg',
        scope: 'viewport',
        resolution: 1,
        includeLegend: false,
        includeWatermark: false,
        backgroundColor: '#ffffff',
      },
      projectName: 'test',
    })

    const svgContent = await readBlobAsText(result.blob)
    expect(svgContent).toContain('fill="#ffffff"')
  })

  it('should not include background rect when backgroundColor is transparent', async () => {
    const result = await exportSvg({
      svgElement: mockSvg,
      options: {
        format: 'svg',
        scope: 'viewport',
        resolution: 1,
        includeLegend: false,
        includeWatermark: false,
        backgroundColor: 'transparent',
      },
      projectName: 'test',
    })

    const svgContent = await readBlobAsText(result.blob)
    // Should not have a rect with 100% width/height as first child
    expect(svgContent).not.toContain('fill="transparent"')
  })

  it('should include legend group when includeLegend is true', async () => {
    const legendSvg = '<svg xmlns="http://www.w3.org/2000/svg"><text>Legend</text></svg>'

    const result = await exportSvg({
      svgElement: mockSvg,
      options: {
        format: 'svg',
        scope: 'viewport',
        resolution: 1,
        includeLegend: true,
        includeWatermark: false,
        backgroundColor: '#ffffff',
      },
      projectName: 'test',
      legendSvg,
    })

    const svgContent = await readBlobAsText(result.blob)
    expect(svgContent).toContain('legend-group')
  })

  it('should include watermark when includeWatermark is true', async () => {
    const result = await exportSvg({
      svgElement: mockSvg,
      options: {
        format: 'svg',
        scope: 'viewport',
        resolution: 1,
        includeLegend: false,
        includeWatermark: true,
        backgroundColor: '#ffffff',
      },
      projectName: 'test',
    })

    const svgContent = await readBlobAsText(result.blob)
    expect(svgContent).toContain('Generated by MonoGuard')
  })

  it('should not include watermark when includeWatermark is false', async () => {
    const result = await exportSvg({
      svgElement: mockSvg,
      options: {
        format: 'svg',
        scope: 'viewport',
        resolution: 1,
        includeLegend: false,
        includeWatermark: false,
        backgroundColor: '#ffffff',
      },
      projectName: 'test',
    })

    const svgContent = await readBlobAsText(result.blob)
    expect(svgContent).not.toContain('Generated by MonoGuard')
  })

  it('should include XML declaration in output', async () => {
    const result = await exportSvg({
      svgElement: mockSvg,
      options: {
        format: 'svg',
        scope: 'viewport',
        resolution: 1,
        includeLegend: false,
        includeWatermark: false,
        backgroundColor: '#ffffff',
      },
      projectName: 'test',
    })

    const svgContent = await readBlobAsText(result.blob)
    expect(svgContent).toContain('<?xml version="1.0" encoding="UTF-8"?>')
  })

  it('should handle full graph scope', async () => {
    const result = await exportSvg({
      svgElement: mockSvg,
      options: {
        format: 'svg',
        scope: 'full',
        resolution: 1,
        includeLegend: false,
        includeWatermark: false,
        backgroundColor: '#ffffff',
      },
      projectName: 'test',
    })

    // Should complete without error and return valid result
    expect(result.blob).toBeInstanceOf(Blob)
    expect(result.filename).toContain('.svg')
  })
})
