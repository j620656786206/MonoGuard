/**
 * SVG Export Utility
 *
 * Exports the dependency graph as a standalone SVG file.
 * Inlines all styles and creates a self-contained SVG document.
 *
 * @see Story 4.6: Export Graph as PNG/SVG Images - AC3, AC4, AC5
 */

import type { ExportOptions, ExportResult } from '../types'

export interface ExportSvgParams {
  /** The SVG element to export */
  svgElement: SVGSVGElement
  /** Export configuration options */
  options: ExportOptions
  /** Project name for filename generation */
  projectName: string
  /** Optional legend SVG string to embed */
  legendSvg?: string
}

/**
 * Exports the dependency graph as an SVG file.
 * Clones the SVG, inlines styles, and produces a standalone document.
 */
export async function exportSvg({
  svgElement,
  options,
  projectName,
  legendSvg,
}: ExportSvgParams): Promise<ExportResult> {
  const clonedSvg = svgElement.cloneNode(true) as SVGSVGElement

  // Inline computed styles for standalone SVG
  inlineStyles(clonedSvg, svgElement)

  // Adjust viewBox for full graph export
  if (options.scope === 'full') {
    const bounds = calculateFullGraphBounds(clonedSvg)
    clonedSvg.setAttribute('viewBox', `${bounds.x} ${bounds.y} ${bounds.width} ${bounds.height}`)
    clonedSvg.setAttribute('width', String(bounds.width))
    clonedSvg.setAttribute('height', String(bounds.height))
  }

  // Add background rectangle if not transparent
  if (options.backgroundColor !== 'transparent') {
    const background = document.createElementNS('http://www.w3.org/2000/svg', 'rect')
    background.setAttribute('width', '100%')
    background.setAttribute('height', '100%')
    background.setAttribute('fill', options.backgroundColor)
    clonedSvg.insertBefore(background, clonedSvg.firstChild)
  }

  // Embed legend if requested
  if (options.includeLegend && legendSvg) {
    const legendGroup = parseLegendSvg(legendSvg, clonedSvg)
    clonedSvg.appendChild(legendGroup)
  }

  // Add watermark if requested
  if (options.includeWatermark) {
    const watermark = createWatermark()
    clonedSvg.appendChild(watermark)
  }

  // Serialize to XML string
  const serializer = new XMLSerializer()
  const svgString = serializer.serializeToString(clonedSvg)
  const svgWithDeclaration = `<?xml version="1.0" encoding="UTF-8"?>\n${svgString}`

  const blob = new Blob([svgWithDeclaration], { type: 'image/svg+xml' })

  const timestamp = new Date().toISOString().split('T')[0]
  const filename = `${projectName}-dependency-graph-${timestamp}.svg`

  return {
    blob,
    filename,
    width: parseInt(clonedSvg.getAttribute('width') || '800', 10),
    height: parseInt(clonedSvg.getAttribute('height') || '600', 10),
  }
}

/**
 * Inline computed styles into SVG elements for standalone export.
 */
function inlineStyles(clonedNode: Element, originalNode: Element) {
  const computedStyle = window.getComputedStyle(originalNode)
  const relevantStyles = [
    'fill',
    'stroke',
    'stroke-width',
    'opacity',
    'font-family',
    'font-size',
    'font-weight',
    'text-anchor',
    'dominant-baseline',
  ]

  let styleString = ''
  relevantStyles.forEach((prop) => {
    const value = computedStyle.getPropertyValue(prop)
    if (value) {
      styleString += `${prop}:${value};`
    }
  })

  if (styleString) {
    ;(clonedNode as SVGElement).style.cssText += styleString
  }

  const originalChildren = originalNode.children
  const clonedChildren = clonedNode.children

  for (let i = 0; i < originalChildren.length; i++) {
    if (clonedChildren[i]) {
      inlineStyles(clonedChildren[i], originalChildren[i])
    }
  }
}

/**
 * Calculate the bounding box of all elements in the SVG.
 */
function calculateFullGraphBounds(svg: SVGSVGElement): {
  x: number
  y: number
  width: number
  height: number
} {
  try {
    const bbox = svg.getBBox()
    const padding = 20
    return {
      x: bbox.x - padding,
      y: bbox.y - padding,
      width: bbox.width + padding * 2,
      height: bbox.height + padding * 2,
    }
  } catch {
    // getBBox may fail in jsdom; fall back to attributes
    return {
      x: 0,
      y: 0,
      width: parseInt(svg.getAttribute('width') || '800', 10),
      height: parseInt(svg.getAttribute('height') || '600', 10),
    }
  }
}

/**
 * Create a watermark text element.
 */
function createWatermark(): SVGGElement {
  const g = document.createElementNS('http://www.w3.org/2000/svg', 'g')
  g.setAttribute('class', 'watermark')

  const text = document.createElementNS('http://www.w3.org/2000/svg', 'text')
  text.setAttribute('x', '10')
  text.setAttribute('y', '99%')
  text.setAttribute('fill', '#999')
  text.setAttribute('font-size', '10')
  text.setAttribute('font-family', 'sans-serif')
  text.textContent = 'Generated by MonoGuard'

  g.appendChild(text)
  return g
}

/**
 * Parse a legend SVG string and wrap in a positioned group.
 */
function parseLegendSvg(legendSvgString: string, parentSvg: SVGSVGElement): SVGGElement {
  const parser = new DOMParser()
  const doc = parser.parseFromString(legendSvgString, 'image/svg+xml')
  const legendSvg = doc.documentElement

  const g = document.createElementNS('http://www.w3.org/2000/svg', 'g')
  g.setAttribute('class', 'legend-group')

  // Position at bottom-right of the SVG
  const svgWidth = parseInt(parentSvg.getAttribute('width') || '800', 10)
  const svgHeight = parseInt(parentSvg.getAttribute('height') || '600', 10)
  const legendWidth = 150
  const legendHeight = 100
  g.setAttribute(
    'transform',
    `translate(${svgWidth - legendWidth - 20}, ${svgHeight - legendHeight - 20})`
  )

  // Copy legend children into group
  Array.from(legendSvg.children).forEach((child) => {
    g.appendChild(child.cloneNode(true))
  })

  return g
}
